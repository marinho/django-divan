=====
Divan
=====

Divan is an application that combines some of the best features of Django
(the forms library, the admin, and the template language) with the flexibility
of CouchDB.  It works something like this:

1. You subclass the ``BaseOption`` model provided by ``divan.models``.
2. You register your subclass with the Django admin application.
3. You, or your users, use this subclass to create "fields" that are mapped to keys
   in CouchDB documents.
4. You subclass the ``CouchForm`` class provided by ``divan.forms``, with a special
   declaration that ties it to your ``BaseOption`` subclass.
5. Your form class will now have all of the fields that you create in the admin, and
   you get a CouchDB document when you call ``form.save()``.

Dependencies
------------

Naturally, Divan requires that you have CouchDB 0.9.x installed (and running).

It also requires the couchdb-python_ library.

If you want to be able to create form fields that use TinyMCE, you also should
install django-tinymce_.

.. _couchdb-python: http://code.google.com/p/couchdb-python/
.. _django-tinymce: http://code.google.com/p/django-tinymce/


Installation
------------

Clone the git repository::

    git clone git://github.com/olifantworkshop/django_divan.git 

Put the django_divan/divan folder somewhere on your PYTHONPATH and add 'divan'
to the INSTALLED_APPS in your settings module.

Getting started
---------------

Start CouchDB on either the default port locally (5984) or an address defined by
``DEFAULT_COUCH_SERVER`` in your Django settings module.

Defining fields
~~~~~~~~~~~~~~~

Divan provides an abstract model class ``BaseOption`` that applications
extend and use to define the fields that will appear in a form/"model"
instance.  This also includes an inner ``Divan`` class::

   class FooOption(BaseOption):
       class Divan:
           database = 'foo'

``BaseOption`` includes the following fields:

``field_name``
    The human readable name of the field.  Used as the argument to the
    ``label`` parameter of the field constructor.

``field_type``
    User-friendly names that map to one of the ``Field`` subclasses in
    ``django.forms.fields``.  See `Supported field types`_.

``input_method``
    Controls a combination of the ``Field`` subclass used (for multiple choice
    values) and widgets applied (TinyMCE, textarea, etc.).

``group``
    String to tag groups of fields.  A future release will include JavaScript
    for auto-completing to ensure consistency across instances.

``key``
    Auto-generated value from ``field_name``, lower-casing the string and
    replacing non-alphanumeric characters with underscores.  When form classes
    are created, the field will be accessible as an attribute with this name.

``required``
    Determines whether or not the field will be required in forms.

``order``
    Secondary sort condition after ``group``.  This is currently useless.  A
    future release will include JavaScript for drag & drop sorting of Option
    instances in the Django admin.

The inner ``Divan`` class can declare a ``database`` attribute, set to the name
of the CouchDB database in which the objects will be created.  If this class is
not defined, Divan will look for ``settings.DEFAULT_COUCH_DATABASE``, and
otherwise throw an error.

The ``Divan`` class can also declare a ``choice_related_name`` attribute for
handling multiple choice questions, as explained below.

Dealing with multiple choice fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to support multiple choice fields, you'll have to subclass
``divan.models.OptionChoice`` and add another declaration to the ``Divan``
inner class of your ``BaseOption`` subclass.

::

    class FooOption(BaseOption):
        class Divan:
            database = 'foo'
            choice_related_name = 'bar_set'

    class Bar(OptionChoice):
        option = models.ForeignKey(FooOption)

The name of the foreign key field on ``Bar`` does not matter.  What does matter
is that the ``choice_related_name`` declaration matches the name of the related
manager for that object.

Supported field types
~~~~~~~~~~~~~~~~~~~~~

The following basic field types are supported and provide the expected validation:

    * ``forms.CharField``
    * ``forms.IntegerField``
    * ``forms.FloatField``
    * ``forms.DateField``
    * ``forms.TimeField``
    * ``forms.DateTimeField``
    * ``forms.EmailField``
    * ``forms.FileField``
    * ``forms.ImageField``
    * ``forms.URLField``
    * ``forms.BooleanField``
    * ``forms.IPAddressField``

Additionally, ``forms.ChoiceField`` and ``forms.MultipleChoiceField`` are
available as input methods.  Important to note, however, is that any
`serialization`_ methods from the field type selected will be applied to each
selected choice.

Forms for the user-defined fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Subclasses of the ``CouchForm`` class provided in ``divan.forms`` declare a
couple of attributes that provide the bridge between CouchDB and the SQL
database::

    class FooForm(CouchForm):
        class Divan:
            model = FooOption
            groups = ['address data']


The fields added to the form will be filtered by the ``FooOption.group``
strings that are declared as a list on the ``group`` attribute of ``Divan``.
If ``group`` is not defined, a field will be created for every instance of
``model``.

``CouchForm`` subclasses inherit from ``BaseForm`` with a different metaclass,
so they have all of the goodies you expect from a Django ``Form`` subclass,
including ``is_valid()``, ``is_bound``, ``initial``, etc.  

They can also be instantiated with an additional keyword argument ``document``,
which should be a ``Document`` object as retrieved from CouchDB by the Python
client library.

Like ``ModelForm`` subclasses, ``CouchForm`` subclasses have a ``save()``
method.  If the given instance was instantiated with an argument to the
``document`` parameter, it will update the document in question; otherwise, it
will create a new one.  ``save()`` returns the new or updated document.

``CouchModel``
~~~~~~~~~~~~~~

Divan provides a wrapper class called ``CouchModel`` that makes it easier to
deal with CouchDB documents in templates.  It does not provide database write
capabilities. It simply gives template authors a few convenient accessors.

``CouchModel`` is subclassed like so::

    
    class Foo(CouchModel):
        class Divan:
            schema = FooOption

Now we instantiate ``Foo`` with the id of a CouchDB document::

    foo = Foo(document_id='bar')

The resulting instance will have attributes corresponding to each instance of
``FooOption`` that you have created, accessible by their respective ``key``
values. Any other keys that happen to be in the document will not be added to
the object.

You can also iterate over the ``CouchModel``::

    for field in foo:
        print field.label, field

``Foo`` will also have a dictionary of fields grouped by the ``group``
attribute of ``FooOption``, which is aptly named ``groups``.  This allows you to
display large documents in a structured manner in the templates.

:: 

    {% for title, fieldset in document.groups.items %}
        <h3>{{ title }}</h3>
        {% for field in fieldset %}
            <p>{{ field.label }}: {{ field }}</p>
        {% endfor %}
    {% endfor %}

Serialization
~~~~~~~~~~~~~

Any of the supported field types may have default serializer/deserializer
functions declared on ``CouchForm`` or ``CouchModel`` subclasses.  For example,
you might want to pad ``IntegerField`` values with leading zeros if you are
using Lucene to drive search over CouchDB documents::

    class FooForm(CouchForm):
        class Divan:
            model = FooOption
            IntegerField = {
                'serialize': lambda i: '%015d' % i,
                'deserialize': lambda s: int(s)
            }

``DateField``, ``DateTimeField``, and ``TimeField`` values are by default
serialized to ISO-8601 timestamps.  This behavior can be overridden as desired.
